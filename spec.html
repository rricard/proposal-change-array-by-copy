<!DOCTYPE html>
<meta charset="utf8" />

<pre class="metadata">
title: Change Array by copy
stage: 2
contributors: Robin Ricard, Ashley Claymore
</pre>

<emu-biblio href="biblio.json"></emu-biblio>

<emu-clause id="sec-indexed-collections">
    <h1>Indexed Collections</h1>

    <emu-clause id="sec-array-objects">
        <h1>Array Objects</h1>

        <emu-clause id="sec-properties-of-the-array-prototype-object">
            <h1>Properties of the Array Prototype Object</h1>

            <emu-clause id="sec-array.prototype.sort">
                <h1>Array.prototype.sort ( _comparefn_ )</h1>

                <emu-note type="editor">This algorithm has not been updated. The only difference is that _comparefn_ is now passed explicitly to SortCompare.</emu-note>

                <p>When the `sort` method is called, the following steps are taken:</p>
                <emu-alg>
                    1. [id="step-array-sort-comparefn"] If _comparefn_ is not *undefined* and IsCallable(_comparefn_) is *false*, throw a *TypeError* exception.
                    1. Let _obj_ be ? ToObject(*this* value).
                    1. [id="step-array-sort-len"] Let _len_ be ? LengthOfArrayLike(_obj_).
                    1. Let _items_ be a new empty List.
                    1. Let _k_ be 0.
                    1. Repeat, while _k_ &lt; _len_,
                        1. Let _Pk_ be ! ToString(ùîΩ(_k_)).
                        1. Let _kPresent_ be ? HasProperty(_obj_, _Pk_).
                        1. If _kPresent_ is *true*, then
                        1. Let _kValue_ be ? Get(_obj_, _Pk_).
                        1. Append _kValue_ to _items_.
                        1. Set _k_ to _k_ + 1.
                    1. Let _itemCount_ be the number of elements in _items_.
                    1. [id="step-array-sort"] Sort _items_ using an implementation-defined sequence of calls to SortCompare <ins>with arguments &laquo; _comparefn_, _a_, _b_ &raquo;, where _a_ and _b_ are the two elements of _items_ to compare</ins>. If any such call returns an abrupt completion, stop before performing any further calls to SortCompare or steps in this algorithm and return that completion.
                    1. Let _j_ be 0.
                    1. Repeat, while _j_ &lt; _itemCount_,
                        1. Perform ? Set(_obj_, ! ToString(ùîΩ(_j_)), _items_[_j_], *true*).
                        1. Set _j_ to _j_ + 1.
                    1. Repeat, while _j_ &lt; _len_,
                        1. Perform ? DeletePropertyOrThrow(_obj_, ! ToString(ùîΩ(_j_))).
                        1. Set _j_ to _j_ + 1.
                    1. Return _obj_.
                </emu-alg>

                <emu-clause id="sec-sortcompare" type="abstract operation">
                    <h1>
                        SortCompare (
                            <ins>_comparefn_</ins>: <ins>an ECMAScript language value</ins>,
                            _x_: unknown,
                            _y_: unknown,
                        )
                    </h1>
                    <dl class="header"></dl>
                    <emu-alg>
                        1. If _x_ and _y_ are both *undefined*, return *+0*<sub>ùîΩ</sub>.
                        1. If _x_ is *undefined*, return *1*<sub>ùîΩ</sub>.
                        1. If _y_ is *undefined*, return *-1*<sub>ùîΩ</sub>.
                        1. If _comparefn_ is not *undefined*, then
                            1. Let _v_ be ? ToNumber(? Call(_comparefn_, *undefined*, &laquo; _x_, _y_ &raquo;)).
                            1. If _v_ is *NaN*, return *+0*<sub>ùîΩ</sub>.
                            1. Return _v_.
                        1. [id="step-sortcompare-tostring-x"] Let _xString_ be ? ToString(_x_).
                        1. [id="step-sortcompare-tostring-y"] Let _yString_ be ? ToString(_y_).
                        1. Let _xSmaller_ be IsLessThan(_xString_, _yString_, *true*).
                        1. If _xSmaller_ is *true*, return *-1*<sub>ùîΩ</sub>.
                        1. Let _ySmaller_ be IsLessThan(_yString_, _xString_, *true*).
                        1. If _ySmaller_ is *true*, return *1*<sub>ùîΩ</sub>.
                        1. Return *+0*<sub>ùîΩ</sub>.
                    </emu-alg>
                </emu-clause>
            </emu-clause>

            <emu-clause id="sec-array.prototype.toReversed">
                <h1>Array.prototype.toReversed ( )</h1>

                <p>When the *toReversed* method is called, the following steps are taken:</p>

                <emu-alg>
                    1. Let _O_ be ? ToObject(*this* value).
                    1. Let _len_ be ? LengthOfArrayLike(_O_).
                    1. Let _A_ be ? ArrayCreate(ùîΩ(_len_)).
                    1. Let _k_ be 0.
                    1. Repeat, while _k_ &lt; _len_,
                        1. Let _from_ be ! ToString(ùîΩ(_len_ - _k_ - 1)).
                        1. Let _Pk_ be ! ToString(ùîΩ(_k_)).
                        1. Let _fromValue_ be ? Get(_O_, _from_).
                        1. Perform ? CreateDataPropertyOrThrow(_A_, _Pk_, _fromValue_).
                        1. Set _k_ to _k_ + 1.
                    1. Return _A_.
                </emu-alg>
            </emu-clause>

            <emu-clause id="sec-array.prototype.toSorted">
                <h1>Array.prototype.toSorted ( _comparefn_ )</h1>

                <p>When the *toSorted* method is called, the following steps are taken:</p>

                <emu-alg>
                    1. If _comparefn_ is not *undefined* and IsCallable(_comparefn_) is *false*, throw a *TypeError* exception.
                    1. Let _O_ be ? ToObject(*this* value).
                    1. Let _len_ be ? LengthOfArrayLike(_O_).
                    1. Let _A_ be ? ArrayCreate(ùîΩ(_len_)).
                    1. Let _items_ be a new empty List.
                    1. Let _k_ be 0.
                    1. Repeat, while _k_ &lt; _len_,
                        1. Let _Pk_ be ! ToString(ùîΩ(_k_)).
                        1. Let _kValue_ be ? Get(_O_, _Pk_).
                        1. Append _kValue_ to _items_.
                        1. Set _k_ to _k_ + 1.
                    1. Sort _items_ using an implementation-defined sequence of calls to SortCompare with arguments &laquo; _comparefn_, _a_, _b_ &raquo;, where _a_ and _b_ are the two elements of _items_ to compare. If any such call returns an abrupt completion, stop before performing any further calls to SortCompare or steps in this algorithm and return that completion.
                    1. Let _j_ be 0.
                    1. For each element _E_ of _items_, do
                        1. Let _Pj_ be ! ToString(ùîΩ(_j_)).
                        1. Perform ? CreateDataPropertyOrThrow(_A_, _Pj_, _E_).
                        1. Set _j_ to _j_ + 1.
                    1. Return _A_.
                </emu-alg>
            </emu-clause>

            <emu-clause id="sec-array.prototype.toSpliced">
                <h1>Array.prototype.toSpliced ( _start_, _deleteCount_, ..._items_ )</h1>

                <p>When the *toSpliced* method is called, the following steps are taken:</p>

                <emu-alg>
                    1. Let _O_ be ? ToObject(*this* value).
                    1. Let _len_ be ? LengthOfArrayLike(_O_).
                    1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).
                    1. If _relativeStart_ is -&infin;, let _actualStart_ be 0.
                    1. Else if _relativeStart_ &lt; 0, let _actualStart_ be max(_len_ + _relativeStart_, 0).
                    1. Else, let _actualStart_ be min(_relativeStart_, _len_).
                    1. Let _insertCount_ be the number of elements in _items_.
                    1. If _start_ is not present, then
                        1. Let _actualDeleteCount_ be 0.
                    1. Else if _deleteCount_ is not present, then
                        1. Let _actualDeleteCount_ be _len_ - _actualStart_.
                    1. Else,
                        1. Let _dc_ be ? ToIntegerOrInfinity(_deleteCount_).
                        1. Let _actualDeleteCount_ be the result of clamping _dc_ between 0 and _len_ - _actualStart_.
                    1. Let _newLen_ be _len_ + _insertCount_ - _actualDeleteCount_.
                    1. Let _A_ be ? ArrayCreate(ùîΩ(_newLen_)).
                    1. Let _k_ be 0.
                    1. Repeat, while _k_ &lt; _actualStart_,
                        1. Let _Pk_ be ! ToString(ùîΩ(_k_)).
                        1. Let _kValue_ be ? Get(_O_, _Pk_).
                        1. Perform ? CreateDataPropertyOrThrow(_A_, _Pk_, _kValue_).
                        1. Set _k_ to _k_ + 1.
                    1. For each element _E_ of _items_, do
                        1. Let _Pk_ be ! ToString(ùîΩ(_k_)).
                        1. Perform ? CreateDataPropertyOrThrow(_A_, _Pk_, _E_).
                        1. Set _k_ to _k_ + 1.
                    1. Repeat, while _k_ &lt; _newLen_,
                        1. Let _Pk_ be ! ToString(ùîΩ(_k_)).
                        1. Let _from_ be ! ToString(ùîΩ(_k_ + _actualDeleteCount_ - _insertCount_)).
                        1. Let _fromValue_ be ? Get(_O_, _from_).
                        1. Perform ? CreateDataPropertyOrThrow(_A_, _Pk_, _fromValue_).
                        1. Set _k_ to _k_ + 1.
                    1. Return _A_.
                </emu-alg>
            </emu-clause>

            <emu-clause id="sec-array.prototype.with">
                <h1>Array.prototype.with ( _index_, _value_ )</h1>

                <p>When the *with* method is called, the following steps are taken:</p>

                <emu-alg>
                    1. Let _O_ be ? ToObject(*this* value).
                    1. Let _len_ be ? LengthOfArrayLike(_O_).
                    1. Let _relativeIndex_ be ? ToIntegerOrInfinity(_index_).
                    1. If _index_ &ge; 0, let _actualIndex_ be _relativeIndex_.
                    1. Else, let _actualIndex_ be _len_ + _relativeIndex_.
                    1. If _actualIndex_ &ge; _len_ or _actualIndex_ &lt; 0, throw a *RangeError* exception.
                    1. Let _A_ be ? ArrayCreate(ùîΩ(_len_)).
                    1. Let _k_ be 0.
                    1. Repeat, while _k_ &lt; _len_,
                        1. Let _Pk_ be ! ToString(ùîΩ(_k_)).
                        1. If _k_ is _actualIndex_, let _fromValue_ be _value_.
                        1. Else, let _fromValue_ be ? Get(_O_, _Pk_).
                        1. Perform ? CreateDataPropertyOrThrow(_A_, _Pk_, _fromValue_).
                        1. Set _k_ to _k_ + 1.
                    1. Return _A_.
                </emu-alg>
            </emu-clause>


            <emu-clause id="sec-array.prototype-@@unscopables">
                <h1>Array.prototype [ @@unscopables ]</h1>
                <p>The initial value of the @@unscopables data property is an object created by the following steps:</p>
                <emu-alg>
                    1. Let _unscopableList_ be ! OrdinaryObjectCreate(*null*).
                    1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"copyWithin"*, *true*).
                    1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"entries"*, *true*).
                    1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"fill"*, *true*).
                    1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"find"*, *true*).
                    1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"findIndex"*, *true*).
                    1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"flat"*, *true*).
                    1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"flatMap"*, *true*).
                    1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"includes"*, *true*).
                    1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"keys"*, *true*).
                    1. <ins>Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"toReversed"*, *true*).</ins>
                    1. <ins>Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"toSorted"*, *true*).</ins>
                    1. <ins>Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"toSpliced"*, *true*).</ins>
                    1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"values"*, *true*).
                    1. Return _unscopableList_.
                </emu-alg>
                <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
            </emu-clause>
        </emu-clause>
    </emu-clause>

    <emu-clause id="sec-typedarray-objects">
        <h1>TypedArray Objects</h1>

        <emu-clause id="sec-abstract-operations-for-typedarray-objects">
            <h1>Abstract Operations for TypedArray Objects</h1>

            <emu-clause id="typedarray-species-create" aoid="TypedArraySpeciesCreate">
                <h1>TypedArraySpeciesCreate ( _exemplar_, _argumentList_ <ins>[ , _noSpeciesOverride_ ] </ins> )</h1>
                <p>The abstract operation TypedArraySpeciesCreate takes arguments _exemplar_, _argumentList_, <ins>and optional argument _noSpeciesOverride_ </ins>. It is used to specify the creation of a new TypedArray object using a constructor function that is derived from _exemplar_. It performs the following steps when called:</p>
                <emu-alg>
                1. Assert: _exemplar_ is an Object that has [[TypedArrayName]] and [[ContentType]] internal slots.
                1. Let _defaultConstructor_ be the intrinsic object listed in column one of <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _exemplar_.[[TypedArrayName]].
                1. <ins>If _noSpeciesOverride_ is *true*, let _constructor_ be _defaultConstructor_.</ins>
                1. <ins>Else, Let _constructor_ be ? SpeciesConstructor(_exemplar_, _defaultConstructor_)</ins>.
                1. <del>Let _constructor_ be ? SpeciesConstructor(_exemplar_, _defaultConstructor_).</del>
                1. Let _result_ be ? TypedArrayCreate(_constructor_, _argumentList_).
                1. Assert: _result_ has [[TypedArrayName]] and [[ContentType]] internal slots.
                1. If _result_.[[ContentType]] &ne; _exemplar_.[[ContentType]], throw a *TypeError* exception.
                1. Return _result_.
                </emu-alg>
            </emu-clause>

        </emu-clause>

        <emu-clause id="sec-%typedarray%-intrinsic-object">
            <h1>The %TypedArray% Intrinsic Object</h1>

            <emu-clause id="sec-properties-of-the-%typedarrayprototype%-object">
                <h1>Properties of the %TypedArray% Prototype Object</h1>

                <emu-clause id="sec-%typedarray%.prototype.sort">
                    <h1>%TypedArray%.prototype.sort ( _comparefn_ )</h1>

                    <emu-note type="editor">This algorithm has not been updated. The only difference is that _comparefn_ and _buffer_ are now passed explicitly to TypedArraySortCompare.</emu-note>

                    <p>Upon entry, the following steps are performed to initialize evaluation of the `sort` function. These steps are used instead of steps <emu-xref href="#step-array-sort-comparefn"></emu-xref>‚Äì<emu-xref href="#step-array-sort-len"></emu-xref> in <emu-xref href="#sec-array.prototype.sort"></emu-xref>:</p>
                    <emu-alg>
                        1. If _comparefn_ is not *undefined* and IsCallable(_comparefn_) is *false*, throw a *TypeError* exception.
                        1. Let _obj_ be the *this* value.
                        1. Perform ? ValidateTypedArray(_obj_).
                        1. Let _buffer_ be _obj_.[[ViewedArrayBuffer]].
                        1. Let _len_ be _obj_.[[ArrayLength]].
                    </emu-alg>

                    <p><ins>Instead of calling SortCompare with arguments &laquo; _comparefn_, _a_, _b_ &raquo;, it calls TypedArraySortCompare with arguments &laquo; _comparefn_, _buffer_, _a_, _b_ &raquo;.</ins></p>

                    <emu-clause id="sec-typedarraysortcompare" type="abstract operation">
                        <h1>
                            TypedArraySortCompare (
                                <ins>_comparefn_</ins>: <ins>an ECMAScript language value</ins>,
                                <ins>_buffer_</ins>: <ins>unknown</ins>,
                                _x_: a Number or BigInt,
                                _y_: a Number or BigInt,
                            )
                        </h1>
                        <dl class="header">
                            <dt>description</dt>
                            <dd>It performs a numeric comparison rather than the string comparison used in <emu-xref href="#sec-array.prototype.sort"></emu-xref>.</dd>
                        </dl>

                    </p>
                    <emu-alg>
                        1. Assert: Both Type(_x_) and Type(_y_) are Number or both are BigInt.
                        1. If _comparefn_ is not *undefined*, then
                            1. Let _v_ be ? ToNumber(? Call(_comparefn_, *undefined*, &laquo; _x_, _y_ &raquo;)).
                            1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.
                            1. If _v_ is *NaN*, return *+0*<sub>ùîΩ</sub>.
                            1. Return _v_.
                        1. If _x_ and _y_ are both *NaN*, return *+0*<sub>ùîΩ</sub>.
                        1. If _x_ is *NaN*, return *1*<sub>ùîΩ</sub>.
                        1. If _y_ is *NaN*, return *-1*<sub>ùîΩ</sub>.
                        1. If _x_ &lt; _y_, return *-1*<sub>ùîΩ</sub>.
                        1. If _x_ &gt; _y_, return *1*<sub>ùîΩ</sub>.
                        1. If _x_ is *-0*<sub>ùîΩ</sub> and _y_ is *+0*<sub>ùîΩ</sub>, return *-1*<sub>ùîΩ</sub>.
                        1. If _x_ is *+0*<sub>ùîΩ</sub> and _y_ is *-0*<sub>ùîΩ</sub>, return *1*<sub>ùîΩ</sub>.
                        1. Return *+0*<sub>ùîΩ</sub>.
                    </emu-alg>
                    <emu-note>
                        <p>Because *NaN* always compares greater than any other value, *NaN* property values always sort to the end of the result when _comparefn_ is not provided.</p>
                    </emu-note>
                </emu-clause>

                <emu-clause id="sec-%typedarray%.prototype.toReversed">
                    <h1>%TypedArray%.prototype.toReversed ( )</h1>

                    <p>When the *toReversed* method is called, the following steps are taken:</p>

                    <emu-alg>
                        1. Let _O_ be the *this* value.
                        1. Perform ? ValidateTypedArray(_O_).
                        1. Let _length_ be _O_.[[ArrayLength]].
                        1. Let _A_ be ? TypedArraySpeciesCreate(_O_, &laquo; ùîΩ(_length_) &raquo;, *true*).
                        1. Let _k_ be 0.
                        1. Repeat, while _k_ &lt; _length_,
                            1. Let _from_ be ! ToString(ùîΩ(_length_ - _k_ - 1)).
                            1. Let _Pk_ be ! ToString(ùîΩ(_k_)).
                            1. Let _fromValue_ be ! Get(_O_, _from_).
                            1. Perform ? Set(_A_, _Pk_, _kValue_, *true*).
                            1. Set _k_ to _k_ + 1.
                        1. Return _A_.
                    </emu-alg>
                </emu-clause>

                <emu-clause id="sec-%typedarray%.prototype.toSorted">
                    <h1>%TypedArray%.prototype.toSorted ( _comparefn_ )</h1>

                    <p>When the *toSorted* method is called, the following steps are taken:</p>

                    <emu-alg>
                        1. If _comparefn_ is not *undefined* and IsCallable(_comparefn_) is *false*, throw a *TypeError* exception.
                        1. Let _O_ be the *this* value.
                        1. Perform ? ValidateTypedArray(_O_).
                        1. Let _buffer_ be _obj_.[[ViewedArrayBuffer]].
                        1. Let _len_ be _O_.[[ArrayLength]].
                        1. Let _A_ be ? TypedArraySpeciesCreate(_O_, &laquo; ùîΩ(_len_) &raquo;, *true*).
                        1. Let _items_ be a new empty List.
                        1. Let _k_ be 0.
                        1. Repeat, while _k_ &lt; _len_,
                            1. Let _Pk_ be ! ToString(ùîΩ(_k_)).
                            1. Let _kValue_ be ? Get(_O_, _Pk_).
                            1. Append _kValue_ to _items_.
                            1. Set _k_ to _k_ + 1.
                        1. Sort _items_ using an implementation-defined sequence of calls to TypedArraySortCompare with arguments &laquo; _comparefn_, _buffer_, _a_, _b_ &raquo;, where _a_ and _b_ are the two elements of _items_ to compare. If any such call returns an abrupt completion, stop before performing any further calls to TypedArraySortCompare or steps in this algorithm and return that completion.
                        1. Let _j_ be 0.
                        1. For each element _E_ of _items_, do
                            1. Let _Pj_ be ! ToString(ùîΩ(_j_)).
                            1. Perform ? Set(_A_, _Pj_, _E_, *true*).
                            1. Set _j_ to _j_ + 1.
                        1. Return _A_.
                    </emu-alg>
                </emu-clause>

                <emu-clause id="sec-%typedarray%.prototype.toSpliced">
                    <h1>%TypedArray%.prototype.toSpliced ( _start_, _deleteCount_, ..._items_ )</h1>

                    <p>When the *toSpliced* method is called, the following steps are taken:</p>

                    <emu-alg>
                        1. Let _O_ be the *this* value.
                        1. Perform ? ValidateTypedArray(_O_).
                        1. Let _len_ be _O_.[[ArrayLength]].
                        1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).
                        1. If _relativeStart_ is -&infin;, let _actualStart_ be 0.
                        1. Else if _relativeStart_ &lt; 0, let _actualStart_ be max(_len_ + _relativeStart_, 0).
                        1. Else, let _actualStart_ be min(_relativeStart_, _len_).
                        1. If _start_ is not present, then
                            1. Let _insertCount_ be 0.
                            1. Let _actualDeleteCount_ be 0.
                        1. Else if _deleteCount_ is not present, then
                            1. Let _insertCount_ be 0.
                            1. Let _actualDeleteCount_ be _len_ - _actualStart_.
                        1. Else,
                            1. Let _insertCount_ be the number of elements in _items_.
                            1. Let _dc_ be ? ToIntegerOrInfinity(_deleteCount_).
                            1. Let _actualDeleteCount_ be the result of clamping _dc_ between 0 and _len_ - _actualStart_.
                        1. Let _newLen_ be _len_ + _insert_Count_ - _actualDeleteCount_.
                        1. Let _A_ be ? TypedArraySpeciesCreate(_O_, &laquo; ùîΩ(_newLen_) &raquo;, *true*).
                        1. Let _k_ be 0.
                        1. Repeat, while _k_ &lt; _actualStart_,
                            1. Let _Pk_ be ! ToString(ùîΩ(_k_)).
                            1. Let _kValue_ be ! Get(_src_, _Pk_).
                            1. Perform ? Set(_target_, _Pk_, _kValue_, *true*).
                            1. Set _k_ to _k_ + 1.
                        1. For each element _E_ of _items_, do
                            1. Let _Pk_ be ! ToString(ùîΩ(_k_)).
                            1. Perform ? Set(_A_, _Pk_, _E_, *true*).
                            1. Set _k_ to _k_ + 1.
                        1. Repeat, while _k_ &lt; _newLen_,
                            1. Let _Pk_ be ! ToString(ùîΩ(_k_)).
                            1. Let _from_ be ! ToString(ùîΩ(_k_ + _actualDeleteCount_ - _insertCount_)).
                            1. Let _fromValue_ be ! Get(_O_, _from_).
                            1. Perform ? Set(_A_, _Pk_, _fromValue_, *true*).
                            1. Set _k_ to _k_ + 1.
                        1. Return _A_.
                    </emu-alg>
                </emu-clause>

                <emu-clause id="sec-%typedarray%.prototype.with">
                    <h1>%TypedArray%.prototype.with ( _index_, _value_ )</h1>

                    <p>When the *with* method is called, the following steps are taken:</p>

                    <emu-alg>
                        1. Let _O_ be the *this* value.
                        1. Perform ? ValidateTypedArray(_O_).
                        1. Let _len_ be _O_.[[ArrayLength]].
                        1. Let _relativeIndex_ be ? ToIntegerOrInfinity(_index_).
                        1. If _index_ &ge; 0, let _actualIndex_ be _relativeIndex_.
                        1. Else, let _actualIndex_ be _len_ + _relativeIndex_.
                        1. If ! IsValidIntegerIndex(_O_, _actualIndex_) is *false*, throw a *RangeError* exception.
                        1. Let _A_ be ? TypedArraySpeciesCreate(_O_, &laquo; ùîΩ(_len_) &raquo;, *true*).
                        1. Let _k_ be 0.
                        1. Repeat, while _k_ &lt; _len_,
                            1. Let _Pk_ be ! ToString(ùîΩ(_k_)).
                            1. If _k_ is _actualIndex_, let _fromValue_ be _value_.
                            1. Else, let _fromValue_ be ! Get(_O_, _Pk_).
                            1. Perform ? Set(_A_, _Pk_, _fromValue_, *true*).
                            1. Set _k_ to _k_ + 1.
                        1. Return _A_.
                    </emu-alg>
                </emu-clause>
            </emu-clause>
        </emu-clause>
    </emu-clause>
</emu-clause>
