<!DOCTYPE html>
<meta charset="utf8" />

<pre class="metadata">
title: Change Array by copy
stage: 0
contributors: Robin Ricard, Ashley Claymore
</pre>

<emu-biblio href="biblio.json"></emu-biblio>

<emu-clause id="sec-indexed-collections">
    <h1>Indexed Collections</h1>

    <emu-clause id="sec-array-objects">
        <h1>Array Objects</h1>

        <emu-clause id="sec-properties-of-the-array-prototype-object">
            <h1>Properties of the Array Prototype Object</h1>

            <emu-clause id="sec-array.prototype.withCopiedWithin">
                <h1>Array.prototype.withCopiedWithin( _target_ , _start_ [ , _end_ ] )</h1>

                <p>When the *withCopiedWithin* method is called, the following steps are taken:</p>

                <emu-alg>
                    1. Let _O_ be ? ToObject(*this* value).
                    1. Let _len_ be ? LengthOfArrayLike(_O_).
                    1. Let _A_ be ? ArrayCreate(ùîΩ(_len_)).
                    1. Let _relativeTarget_ be ? ToIntegerOrInfinity(_target_).
                    1. If _relativeTarget_ is -&infin;, let _actualTarget_ be 0.
                    1. Else if _relativeTarget_ &lt; 0, let _actualTarget_ be max(_len_ + _relativeTarget_, 0).
                    1. Else, let _actualTarget_ be min(_actualTarget_, _len_).
                    1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).
                    1. If _relativeStart_ is -&infin;, let _actualStart_ be 0.
                    1. Else if _relativeStart_ &lt; 0, let _actualStart_ be max(_len_ + _relativeStart_, 0).
                    1. Else, let _actualStart_ be min(_relativeStart_, _len_).
                    1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).
                    1. If _relativeEnd_ is -&infin;, let _actualEnd 0.
                    1. Else if _relativeEnd_ &lt; 0, let _actualEnd max(_len_ + _relativeEnd_, 0).
                    1. Else, let _actualEnd_ be min(_relativeEnd_, _len_).
                    1. Let _k_ be 0.
                    1. Repeat, while _k_ &lt; _actualTarget_,
                        1. Let _Pk_ be ! ToString(ùîΩ(_k_)).
                        1. Let _elementK_ be ? Get(_O_, _Pk_).
                        1. Perform ? CreateDataPropertyOrThrow(_A_, _Pk_, _elementK_).
                        1. Set _k_ to _k_ + 1.
                    1. Let _from_ be _actualStart_.
                    1. Repeat, while _from_ &lt; _actualEnd_ and _k_ &lt; _len_,
                        1. Let _Pk_ be ! ToString(ùîΩ(_k_)).
                        1. Let _Pfrom_ be ! ToString(ùîΩ(_from_)).
                        1. Let _fromValue_ be ? Get(_O_, _Pfrom_).
                        1. Perform ? CreateDataPropertyOrThrow(_A_, _Pk_, _fromValue_).
                        1. Set _k_ to _k_ + 1.
                        1. Set _from_ to _from_ + 1.
                    1. Repeat, while _k_ &lt; _len_,
                        1. Let _Pk_ be ! ToString(ùîΩ(_k_)).
                        1. Let _elementK_ be ? Get(_O_, _Pk_).
                        1. Perform ? CreateDataPropertyOrThrow(_A_, _Pk_, _elementK_).
                        1. Set _k_ to _k_ + 1.
                    1. Return _A_.
                </emu-alg>
            </emu-clause>

            <emu-clause id="sec-array.prototype.withFilled">
                <h1>Array.prototype.withFilled ( _value_ [ , _start_ [ , _end_ ] ] )</h1>

                <p>When the *withFilled* method is called, the following steps are taken:</p>

                <emu-alg>
                    1. Let _O_ be ? ToObject(*this* value).
                    1. Let _len_ be ? LengthOfArrayLike(_O_).
                    1. Let _A_ be ? ArrayCreate(ùîΩ(_len_)).
                    1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).
                    1. If _relativeStart_ is -&infin;, let _actualStart_ be 0.
                    1. Else if _relativeStart_ &lt; 0, let _actualStart_ be max(_len_ + _relativeStart_, 0).
                    1. Else, let _actualStart_ be min(_relativeStart_, _len_).
                    1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).
                    1. If _relativeEnd_ is -&infin;, let _actualEnd_ be 0.
                    1. Else if _relativeEnd_ &lt; 0, let _actualEnd_ be max(_len_ + _relativeEnd_, 0).
                    1. Else, let _actualEnd_ be min(_relativeEnd_, _len_).
                    1. Let _k_ be 0.
                    1. Repeat, while _k_ &lt; _actualStart_,
                        1. Let _Pk_ be ! ToString(ùîΩ(_k_)).
                        1. Let _elementK_ be ? Get(_O_, _Pk_).
                        1. Perform ? CreateDataPropertyOrThrow(_A_, _Pk_, _elementK_).
                        1. Set _k_ to _k_ + 1.
                    1. Repeat, while _k_ &lt; _actualEnd_,
                        1. Let _Pk_ be ! ToString(ùîΩ(_k_)).
                        1. Perform ? CreateDataPropertyOrThrow(_A_, _Pk_, _value_).
                        1. Set _k_ to _k_ + 1.
                    1. Repeat, while _k_ &lt; _len_,
                        1. Let _Pk_ be ! ToString(ùîΩ(_k_)).
                        1. Let _elementK_ be ? Get(_O_, _Pk_).
                        1. Perform ? CreateDataPropertyOrThrow(_A_, _Pk_, _elementK_).
                        1. Set _k_ to _k_ + 1.
                    1. Return _A_.
                </emu-alg>
            </emu-clause>

            <emu-clause id="sec-array.prototype.withPopped">
                <h1>Array.prototype.withPopped ( )</h1>

                <p>When the *withPopped* method is called, the following steps are taken:</p>

                <emu-alg>
                    1. Let _O_ be ? ToObject(*this* value).
                    1. Let _len_ be ? LengthOfArrayLike(_O_).
                    1. Let _newLen_ be max(_len_ - 1, 0).
                    1. Let _A_ be ? ArrayCreate(ùîΩ(_newLen_)).
                    1. Let _k_ be 0.
                    1. Repeat, while _k_ &lt; _newLen_,
                        1. Let _Pk_ be ! ToString(ùîΩ(_k_)).
                        1. Let _elementK_ be ? Get(_O_, _Pk_).
                        1. Perform ? CreateDataPropertyOrThrow(_A_, _Pk_, _elementK_).
                        1. Set _k_ to _k_ + 1.
                    1. Return _A_.
                </emu-alg>
            </emu-clause>

            <emu-clause id="sec-array.prototype.withPushed">
                <h1>Array.prototype.withPushed ( ..._items_ )</h1>

                <p>When the *withPushed* method is called, the following steps are taken:</p>

                <emu-alg>
                    1. Let _O_ be ? ToObject(*this* value).
                    1. Let _itemCount_ be the number of elements in _items_.
                    1. Let _len_ be ? LengthOfArrayLike(_O_).
                    1. let _newLen_ be _len_ + _itemCount_.
                    1. Let _A_ be ? ArrayCreate(ùîΩ(_newLen_)).
                    1. Let _k_ be 0.
                    1. Repeat, while _k_ &lt; _len_,
                        1. Let _Pk_ be ! ToString(ùîΩ(_k_)).
                        1. Let _elementK_ be ? Get(_O_, _Pk_).
                        1. Perform ? CreateDataPropertyOrThrow(_A_, _Pk_, _elementK_).
                        1. Set _k_ to _k_ + 1.
                    1. For each element _E_ of _items_, do
                        1. Assert: _k_ &lt; _newLen_.
                        1. Let _Pk_ be ! ToString(ùîΩ(_k_)).
                        1. Perform ? CreateDataPropertyOrThrow(_A_, _Pk_, _E_).
                        1. Set _k_ to _k_ + 1.
                    1. Return _A_.
                </emu-alg>
            </emu-clause>

            <emu-clause id="sec-array.prototype.withReversed">
                <h1>Array.prototype.withReversed ( )</h1>

                <p>When the *withReversed* method is called, the following steps are taken:</p>

                <emu-alg>
                    1. Let _O_ be ? ToObject(*this* value).
                    1. Let _len_ be ? LengthOfArrayLike(_O_).
                    1. Let _A_ be ? ArrayCreate(ùîΩ(_len_)).
                    1. Let _k_ be 0.
                    1. Repeat, while _k_ &lt; _len_,
                        1. Let _from_ be ! ToString(ùîΩ(_len_ - _k_ - 1)).
                        1. Let _Pk_ be ! ToString(ùîΩ(_k_)).
                        1. Let _fromValue_ be ? Get(_O_, _from_).
                        1. Perform ? CreateDataPropertyOrThrow(_A_, _Pk_, _fromValue_).
                        1. Set _k_ to _k_ + 1.
                    1. Return _A_.
                </emu-alg>
            </emu-clause>

            <emu-clause id="sec-array.prototype.withShifted">
                <h1>Array.prototype.withShifted ( )</h1>

                <p>When the *withShifted* method is called, the following steps are taken:</p>

                <emu-alg>
                    1. Let _O_ be ? ToObject(*this* value).
                    1. Let _len_ be ? LengthOfArrayLike(_O_).
                    1. Let _newLen_ be max(_len_ - 1, 0).
                    1. Let _A_ be ? ArrayCreate(ùîΩ(_newLen_)).
                    1. Let _k_ be 0.
                    1. Repeat, while _k_ &lt; _newLen_,
                        1. Let _Pk_ be ! ToString(ùîΩ(_k_)).
                        1. Let _from_ be ! ToString(ùîΩ(_k_ + 1)).
                        1. Let _fromValue_ be ? Get(_O_, _from_).
                        1. Perform ? CreateDataPropertyOrThrow(_A_, _Pk_, _fromValue_).
                        1. Set _k_ to _k_ + 1.
                    1. Return _A_.
                </emu-alg>
            </emu-clause>

            <emu-clause id="sec-array.prototype.withSorted">
                <h1>Array.prototype.withSorted ( _compareFn_ )</h1>

                <p>When the *withSorted* method is called, the following steps are taken:</p>

                <emu-alg>
                    1. If _comparefn_ is not *undefined* and IsCallable(_comparefn_) is *false*, throw a *TypeError* exception.
                    1. Let _O_ be ? ToObject(*this* value).
                    1. Let _len_ be ? LengthOfArrayLike(_O_).
                    1. Let _items_ be a new empty List.
                    1. Let _k_ be 0.
                    1. Repeat, while _k_ &lt; _len_,
                        1. Let _Pk_ be ! ToString(ùîΩ(_k_)).
                        1. Let _kValue_ be ? Get(_O_, _Pk_).
                        1. Append _kValue_ to _items_.
                        1. Set _k_ to _k_ + 1.
                    1. Sort _items_ using an implementation-defined sequence of calls to SortCompare. If any such call returns an abrupt completion, stop before performing any further calls to SortCompare or steps in this algorithm and return that completion.
                    1. Let _A_ be ? ArrayCreate(ùîΩ(_len_)).
                    1. Let _j_ be 0.
                    1. For each element _E_ of _items_, do
                        1. Let _Pj_ be ! ToString(ùîΩ(_j_)).
                        1. Perform ? CreateDataPropertyOrThrow(_A_, _Pj_, _E_).
                        1. Set _j_ to _j_ + 1.
                    1. Return _A_.
                </emu-alg>
            </emu-clause>

            <emu-clause id="sec-array.prototype.withSpliced">
                <h1>Array.prototype.withSpliced ( _start_, _deleteCount_, ..._items_ )</h1>

                <p>When the *withSpliced* method is called, the following steps are taken:</p>

                <emu-alg>
                    1. Let _O_ be the *this* value.
                    1. Let _len_ be ? LengthOfArrayLike(_O_).
                    1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).
                    1. If _relativeStart_ is -&infin;, let _actualStart_ be 0.
                    1. Else if _relativeStart_ &lt; 0, let _actualStart_ be max(_len_ + _relativeStart_, 0).
                    1. Else, let _actualStart_ be min(_relativeStart_, _len_).
                    1. If _start_ is not present, then
                        1. Let _insertCount_ be 0.
                        1. Let _actualDeleteCount_ be 0.
                    1. Else if _deleteCount_ is not present, then
                        1. Let _insertCount_ be 0.
                        1. Let _actualDeleteCount_ be _len_ - _actualStart_.
                    1. Else,
                        1. Let _insertCount_ be the number of elements in _items_.
                        1. Let _dc_ be ? ToIntegerOrInfinity(_deleteCount_).
                        1. Let _actualDeleteCount_ be the result of clamping _dc_ between 0 and _len_ - _actualStart_.
                    1. Let _newLen_ be _len_ + _insert_Count_ - _actualDeleteCount_.
                    1. Let _A_ be ? ArrayCreate(ùîΩ(_newLen_)).
                    1. Let _k_ be 0.
                    1. Repeat, while _k_ &lt; _newLen_,
                        1. Let _Pk_ be ! ToString(ùîΩ(_k_)).
                        1. Let _kValue_ be ? Get(_O_, _Pk_).
                        1. Perform ? CreateDataPropertyOrThrow(_A_, _Pk_, _kValue_).
                        1. Set _k_ to _k_ + 1.
                    1. Let _k_ be _actualStart_.
                    1. For each element _E_ of _items_, do
                        1. Let _Pk_ be ! ToString(ùîΩ(_k_)).
                        1. Perform ? CreateDataPropertyOrThrow(_A_, _Pk_, _E_).
                        1. Set _k_ to _k_ + 1.
                    1. Repeat, while _k_ &lt; _newLen_,
                        1. Let _Pk_ be ! ToString(ùîΩ(_k_)).
                        1. Let _from_ be ! ToString(ùîΩ(_k_ + _actualDeleteCount_ - _insertCount_)).
                        1. Let _fromValue_ be ? Get(_O_, _from_).
                        1. Perform ? CreateDataPropertyOrThrow(_A_, _Pk_, _fromValue_).
                        1. Set _k_ to _k_ + 1.
                    1. Return _A_.
                </emu-alg>
            </emu-clause>

            <emu-clause id="sec-array.prototype.withUnshifted">
                <h1>Array.prototype.withUnshifted ( ..._items_ )</h1>

                <p>When the *withUnshifted* method is called, the following steps are taken:</p>

                <emu-alg>
                    1. Let _itemCount_ be the number of elements in _items_.
                    1. Let _O_ be the *this* value.
                    1. Let _len_ be ? LengthOfArrayLike(_O_).
                    1. Let _newLen_ be _len_ + _itemCount_.
                    1. Let _A_ be ? ArrayCreate(ùîΩ(_newLen_)).
                    1. Let _k_ be 0.
                    1. For each element _E_ of _items_, do
                        1. Let _Pk_ be ! ToString(ùîΩ(_k_)).
                        1. Perform ? CreateDataPropertyOrThrow(_A_, _Pk_, _E_).
                        1. Set _k_ to _k_ + 1.
                    1. Let _from_ be 0.
                    1. Repeat, while _k_ &lt; _newLen_,
                        1. Let _Pk_ be ! ToString(ùîΩ(_k_)).
                        1. Let _Pfrom_ be ! ToString(ùîΩ(_from_)).
                        1. Let _fromValue_ be ? Get(_O_, _Pfrom_).
                        1. Perform ? CreateDataPropertyOrThrow(_A_, _Pk_, _fromValue_).
                        1. Set _k_ to _k_ + 1.
                        1. Set _from_ to _from_ + 1.
                    1. Return _A_.
                </emu-alg>
            </emu-clause>

            <emu-clause id="sec-array.prototype.withAt">
                <h1>Array.prototype.withAt ( _index_, _value_ )</h1>

                <p>When the *withAt* method is called, the following steps are taken:</p>

                <emu-alg>
                    1. Let _O_ be the *this* value.
                    1. Let _len_ be ? LengthOfArrayLike(_O_).
                    1. If IsIntegralNumber(_index_) is *false*, throw a *RangeError* exception.
                    1. If _index_ &ge; _len_, throw a *RangeError* exception.
                    1. If _index_ &lt; 0, let _actualIndex_ be _len_ + _index_.
                    1. Else, let _actualIndex_ be _index_.
                    1. If _actualIndex_ &lt; 0, throw a *RangeError* exception.
                    1. Let _A_ be ? ArrayCreate(ùîΩ(_len_)).
                    1. Let _k_ be 0.
                    1. Repeat, while _k_ &lt; _len_,
                        1. Let _Pk_ be ! ToString(ùîΩ(_k_)).
                        1. If _k_ is _actualIndex_, let _fromValue_ be _value_.
                        1. Else, let _fromValue_ be ? Get(_O_, _Pk_).
                        1. Perform ? CreateDataPropertyOrThrow(_A_, _Pk_, _fromValue_).
                        1. Set _k_ to _k_ + 1.
                    1. Return _A_.
                </emu-alg>
            </emu-clause>


            <emu-clause id="sec-array.prototype-@@unscopables">
                <h1>Array.prototype [ @@unscopables ]</h1>
                <p>The initial value of the @@unscopables data property is an object created by the following steps:</p>
                <emu-alg>
                    1. Let _unscopableList_ be ! OrdinaryObjectCreate(*null*).
                    1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"copyWithin"*, *true*).
                    1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"entries"*, *true*).
                    1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"fill"*, *true*).
                    1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"find"*, *true*).
                    1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"findIndex"*, *true*).
                    1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"flat"*, *true*).
                    1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"flatMap"*, *true*).
                    1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"includes"*, *true*).
                    1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"keys"*, *true*).
                    1. <ins>Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"withAt"*, *true*).</ins>
                    1. <ins>Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"withCopiedWithin"*, *true*).</ins>
                    1. <ins>Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"withFilled"*, *true*).</ins>
                    1. <ins>Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"withPopped"*, *true*).</ins>
                    1. <ins>Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"withPushed"*, *true*).</ins>
                    1. <ins>Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"withReversed"*, *true*).</ins>
                    1. <ins>Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"withShifted"*, *true*).</ins>
                    1. <ins>Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"withSorted"*, *true*).</ins>
                    1. <ins>Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"withSpliced"*, *true*).</ins>
                    1. <ins>Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"withUnshifted"*, *true*).</ins>
                    1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"values"*, *true*).
                    1. Return _unscopableList_.
                </emu-alg>
                <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
            </emu-clause>
        </emu-clause>
    </emu-clause>

    <emu-clause id="sec-typedarray-objects">
        <h1>TypedArray Objects</h1>

        <emu-clause id="sec-abstract-operations-for-typedarray-objects">
            <h1>Abstract Operations for TypedArray Objects</h1>

            <emu-clause id="typedarray-species-create" aoid="TypedArraySpeciesCreate">
                <h1>TypedArraySpeciesCreate ( _exemplar_, _argumentList_ <ins>[ , _noSpeciesOverride_ ] </ins> )</h1>
                <p>The abstract operation TypedArraySpeciesCreate takes arguments _exemplar_, _argumentList_, <ins>and optional argument _noSpeciesOverride_ </ins>. It is used to specify the creation of a new TypedArray object using a constructor function that is derived from _exemplar_. It performs the following steps when called:</p>
                <emu-alg>
                1. Assert: _exemplar_ is an Object that has [[TypedArrayName]] and [[ContentType]] internal slots.
                1. Let _defaultConstructor_ be the intrinsic object listed in column one of <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _exemplar_.[[TypedArrayName]].
                1. <ins>If _noSpeciesOverride_ is *true*, let _constructor_ be _defaultConstructor_.</ins>
                1. <ins>Else, Let _constructor_ be ? SpeciesConstructor(_exemplar_, _defaultConstructor_)</ins>.
                1. <del>Let _constructor_ be ? SpeciesConstructor(_exemplar_, _defaultConstructor_).</del>
                1. Let _result_ be ? TypedArrayCreate(_constructor_, _argumentList_).
                1. Assert: _result_ has [[TypedArrayName]] and [[ContentType]] internal slots.
                1. If _result_.[[ContentType]] &ne; _exemplar_.[[ContentType]], throw a *TypeError* exception.
                1. Return _result_.
                </emu-alg>
            </emu-clause>

            <emu-clause id="typedarray-copy-range" aoid="TypedArrayCopyRange">
                <h1>TypedArrayCopyRange ( _src_, _target_, _start_, _limit_ )</h1>
                <p>The abstract operation TypedArrayCopyRange takes arguments _src_ (a TypedArray object), _target_ (a TypedArray object), _start_ (a non-negative integer), and _limit_ (a non-negative integer). It performs the following steps when called:</p>
                <emu-alg>
                    1. Assert: _src_ is an Object that has [[TypedArrayName]] and [[ContentType]] internal slots.
                    1. Assert: _target_ is an Object that has [[TypedArrayName]] and [[ContentType]] internal slots.
                    1. Assert: _start_ is a non-negative integer.
                    1. Assert: _limit_ is a non-negative integer.
                    1. Assert: _limit_ is &le; the length of _src_.
                    1. Assert: _limit_ is &le; the length of _target_.
                    1. Assert: _src_.[[TypedArrayName]] is _target_.[[TypedArrayName]].
                    1. Let _k_ be _start_.
                    1. Repeat, while _k_ &lt; _limit_,
                        1. Let _Pk_ be ! ToString(ùîΩ(_k_)).
                        1. Let _kValue_ be ! Get(_src_, _Pk_).
                        1. Perform ? Set(_target_, _Pk_, _kValue_, *true*).
                        1. Set _k_ to _k_ + 1.
                </emu-alg>
            </emu-clause>
        </emu-clause>

        <emu-clause id="sec-%typedarray%-intrinsic-object">
            <h1>The %TypedArray% Intrinsic Object</h1>

            <emu-clause id="sec-properties-of-the-%typedarrayprototype%-object">
                <h1>Properties of the %TypedArray% Prototype Object</h1>

                <emu-clause id="sec-%typedarray%.prototype.withCopiedWithin">
                    <h1>%TypedArray%.prototype.withCopiedWithin( _target_ , _start_ [ , _end_ ] )</h1>

                    <p>When the *withCopiedWithin* method is called, the following steps are taken:</p>

                    <emu-alg>
                        1. Let _O_ be ? ToObject(*this* value).
                        1. Perform ? ValidateTypedArray(_O_).
                        1. Let _len_ be ? LengthOfArrayLike(_O_).
                        1. Let _A_ be ? TypedArraySpeciesCreate(_O_, &laquo; ùîΩ(_len_) &raquo;, *true*).
                        1. Let _relativeTarget_ be ? ToIntegerOrInfinity(_target_).
                        1. If _relativeTarget_ is -&infin;, let _actualTarget_ be 0.
                        1. Else if _relativeTarget_ &lt; 0, let _actualTarget_ be max(_len_ + _relativeTarget_, 0).
                        1. Else, let _actualTarget_ be min(_actualTarget_, _len_).
                        1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).
                        1. If _relativeStart_ is -&infin;, let _actualStart_ be 0.
                        1. Else if _relativeStart_ &lt; 0, let _actualStart_ be max(_len_ + _relativeStart_, 0).
                        1. Else, let _actualStart_ be min(_relativeStart_, _len_).
                        1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).
                        1. If _relativeEnd_ is -&infin;, let _actualEnd 0.
                        1. Else if _relativeEnd_ &lt; 0, let _actualEnd max(_len_ + _relativeEnd_, 0).
                        1. Else, let _actualEnd_ be min(_relativeEnd_, _len_).
                        1. Perform ? TypedArrayCopyRange(_O_, _A_, *0*<sub>ùîΩ</sub>, ùîΩ(_actualTarget_)).
                        1. Let _to_ be _actualTarget_.
                        1. Let _from_ be _actualStart_.
                        1. Repeat, while _from_ &lt; _actualEnd_ and _to_ &lt; _len_,
                            1. Let _Pto_ be ! ToString(ùîΩ(_to_)).
                            1. Let _Pfrom_ be ! ToString(ùîΩ(_from_)).
                            1. Let _fromValue_ be ? Get(_O_, _Pfrom_).
                            1. Perform ? Set(_A_, _Pto_, _fromValue_, *true*).
                            1. Set _to_ to _to_ + 1.
                            1. Set _from_ to _from_ + 1.
                        1. Perform ? TypedArrayCopyRange(_O_, _A_, ùîΩ(_to_), ùîΩ(_len_)).
                        1. Return _A_.
                    </emu-alg>
                </emu-clause>

                <emu-clause id="sec-%typedarray%.prototype.withFilled">
                    <h1>%TypedArray%.prototype.withFilled ( _value_ [ , _start_ [ , _end_ ] ] )</h1>

                    <p>When the *withFilled* method is called, the following steps are taken:</p>

                    <emu-alg>
                        1. Let _O_ be the *this* value.
                        1. Perform ? ValidateTypedArray(_O_).
                        1. Let _len_ be _O_.[[ArrayLength]].
                        1. If _O_.[[ContentType]] is ~BigInt~, set _value_ to ? ToBigInt(_value_).
                        1. Otherwise, set _value_ to ? ToNumber(_value_).
                        1. Let _A_ be ? TypedArraySpeciesCreate(_O_, &laquo; ùîΩ(_len_) &raquo;, *true*).
                        1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).
                        1. If _relativeStart_ is -&infin;, let _actualStart_ be 0.
                        1. Else if _relativeStart_ &lt; 0, let _actualStart_ be max(_len_ + _relativeStart_, 0).
                        1. Else, let _actualStart_ be min(_relativeStart_, _len_).
                        1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).
                        1. If _relativeEnd_ is -&infin;, let _actualEnd_ be 0.
                        1. Else if _relativeEnd_ &lt; 0, let _actualEnd_ be max(_len_ + _relativeEnd_, 0).
                        1. Else, let _actualEnd_ be min(_relativeEnd_, _len_).
                        1. Perform ? TypedArrayCopyRange(_O_, _A_, *0*<sub>ùîΩ</sub>, ùîΩ(_actualStart_)).
                        1. Let _k_ be _actualStart_.
                        1. Repeat, while _k_ &lt; _actualEnd_,
                            1. Let _Pk_ be ! ToString(ùîΩ(_k_)).
                            1. Perform ? Set(_A_, _Pk_, _value_, *true*).
                            1. Set _k_ to _k_ + 1.
                        1. Perform ? TypedArrayCopyRange(_O_, _A_, ùîΩ(_actualEnd_), ùîΩ(_len_)).
                        1. Return _A_.
                    </emu-alg>
                </emu-clause>

                <emu-clause id="sec-%typedarray%.prototype.withPopped">
                    <h1>%TypedArray%.prototype.withPopped ( )</h1>

                    <p>When the *withPopped* method is called, the following steps are taken:</p>

                    <emu-alg>
                        1. Let _O_ be the *this* value.
                        1. Perform ? ValidateTypedArray(_O_).
                        1. Let _len_ be _O_.[[ArrayLength]].
                        1. Let _newLen_ be max(_len_ - 1, 0).
                        1. Let _A_ be ? TypedArraySpeciesCreate(_O_, &laquo; ùîΩ(_newLen_) &raquo;, *true*).
                        1. Perform ? TypedArrayCopyRange(_O_, _A_, *0*<sub>ùîΩ</sub>, ùîΩ(_newLen_)).
                        1. Return _A_.
                    </emu-alg>
                </emu-clause>

                <emu-clause id="sec-%typedarray%.prototype.withPushed">
                    <h1>%TypedArray%.prototype.withPushed ( ..._items_ )</h1>

                    <p>When the *withPushed* method is called, the following steps are taken:</p>

                    <emu-alg>
                        1. Let _itemCount_ be the number of elements in _items_.
                        1. Let _O_ be the *this* value.
                        1. Perform ? ValidateTypedArray(_O_).
                        1. Let _len_ be _O_.[[ArrayLength]].
                        1. Let _newLen_ be _len_ + _itemCount_.
                        1. Let _A_ be ? TypedArraySpeciesCreate(_O_, &laquo; ùîΩ(_newLen_) &raquo;, *true*).
                        1. Perform ? TypedArrayCopyRange(_O_, _A_, *0*<sub>ùîΩ</sub>, ùîΩ(_len_)).
                        1. Let _k_ be _len_.
                        1. For each element _E_ of _items_, do
                            1. Assert: _k_ &lt; _newLen_.
                            1. Let _Pk_ be ! ToString(ùîΩ(_k_)).
                            1. Perform ? Set(_A_, _Pk_, _E_, *true*).
                            1. Set _k_ to _k_ + 1.
                        1. Return _A_.
                    </emu-alg>
                </emu-clause>

                <emu-clause id="sec-%typedarray%.prototype.withReversed">
                    <h1>%TypedArray%.prototype.withReversed ( )</h1>

                    <p>When the *withReversed* method is called, the following steps are taken:</p>

                    <emu-alg>
                        1. Let _O_ be the *this* value.
                        1. Perform ? ValidateTypedArray(_O_).
                        1. Let _length_ be _O_.[[ArrayLength]].
                        1. Let _A_ be ? TypedArraySpeciesCreate(_O_, &laquo; ùîΩ(_length_) &raquo;, *true*).
                        1. Let _k_ be 0.
                        1. Repeat, while _k_ &lt; _length_,
                            1. Let _from_ be ! ToString(ùîΩ(_length_ - _k_ - 1)).
                            1. Let _Pk_ be ! ToString(ùîΩ(_k_)).
                            1. Let _fromValue_ be ! Get(_O_, _from_).
                            1. Perform ? Set(_A_, _Pk_, _kValue_, *true*).
                            1. Set _k_ to _k_ + 1.
                        1. Return _A_.
                    </emu-alg>
                </emu-clause>

                <emu-clause id="sec-%typedarray%.prototype.withShifted">
                    <h1>%TypedArray%.prototype.withShifted ( )</h1>

                    <p>When the *withShifted* method is called, the following steps are taken:</p>

                    <emu-alg>
                        1. Let _O_ be the *this* value.
                        1. Perform ? ValidateTypedArray(_O_).
                        1. Let _len_ be _O_.[[ArrayLength]].
                        1. Let _newLen_ be max(_len_ - 1, 0).
                        1. Let _A_ be ? TypedArraySpeciesCreate(_O_, &laquo; ùîΩ(_newLen_) &raquo;, *true*).
                        1. Let _k_ be 0.
                        1. Repeat, while _k_ &lt; _newLen_,
                            1. Let _Pk_ be ! ToString(ùîΩ(_k_)).
                            1. Let _from_ be ! ToString(ùîΩ(_k_ + 1)).
                            1. Let _fromValue_ be ! Get(_O_, _from_).
                            1. Perform ? Set(_A_, _Pk_, _fromValue_, *true*).
                            1. Set _k_ to _k_ + 1.
                        1. Return _A_.
                    </emu-alg>
                </emu-clause>

                <emu-clause id="sec-%typedarray%.prototype.withSorted">
                    <h1>%TypedArray%.prototype.withSorted ( _compareFn_ )</h1>

                    <p>When the *withSorted* method is called, the following steps are taken:</p>

                    <emu-alg>
                        1. If _comparefn_ is not *undefined* and IsCallable(_comparefn_) is *false*, throw a *TypeError* exception.
                        1. Let _O_ be the *this* value.
                        1. Perform ? ValidateTypedArray(_O_).
                        1. Let _len_ be _O_.[[ArrayLength]].
                        1. Let _items_ be a new empty List.
                        1. Let _k_ be 0.
                        1. Repeat, while _k_ &lt; _len_,
                            1. Let _Pk_ be ! ToString(ùîΩ(_k_)).
                            1. Let _kValue_ be ? Get(_O_, _Pk_).
                            1. Append _kValue_ to _items_.
                            1. Set _k_ to _k_ + 1.
                        1. Sort _items_ using an implementation-defined sequence of calls to SortCompare. If any such call returns an abrupt completion, stop before performing any further calls to SortCompare or steps in this algorithm and return that completion.
                        1. Let _A_ be ? TypedArraySpeciesCreate(_O_, &laquo; ùîΩ(_len_) &raquo;, *true*).
                        1. Let _j_ be 0.
                        1. For each element _E_ of _items_, do
                            1. Let _Pj_ be ! ToString(ùîΩ(_j_)).
                            1. Perform ? Set(_A_, _Pj_, _E_, *true*).
                            1. Set _j_ to _j_ + 1.
                        1. Return _A_.
                    </emu-alg>
                    <p>The following version of SortCompare is used by %TypedArray%`.prototype.withSorted`.</p>
                    <p>The abstract operation TypedArraySortCompare performs the following steps when called:</p>
                    <emu-alg>
                        1. Assert: Both Type(_x_) and Type(_y_) are Number or both are BigInt.
                        1. If _comparefn_ is not *undefined*, then
                            1. Let _v_ be ? ToNumber(? Call(_comparefn_, *undefined*, &laquo; _x_, _y_ &raquo;)).
                            1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.
                            1. If _v_ is *NaN*, return *+0*<sub>ùîΩ</sub>.
                            1. Return _v_.
                        1. If _x_ and _y_ are both *NaN*, return *+0*<sub>ùîΩ</sub>.
                        1. If _x_ is *NaN*, return *1*<sub>ùîΩ</sub>.
                        1. If _y_ is *NaN*, return *-1*<sub>ùîΩ</sub>.
                        1. If _x_ &lt; _y_, return *-1*<sub>ùîΩ</sub>.
                        1. If _x_ &gt; _y_, return *1*<sub>ùîΩ</sub>.
                        1. If _x_ is *-0*<sub>ùîΩ</sub> and _y_ is *+0*<sub>ùîΩ</sub>, return *-1*<sub>ùîΩ</sub>.
                        1. If _x_ is *+0*<sub>ùîΩ</sub> and _y_ is *-0*<sub>ùîΩ</sub>, return *1*<sub>ùîΩ</sub>.
                        1. Return *+0*<sub>ùîΩ</sub>.
                    </emu-alg>
                </emu-clause>

                <emu-clause id="sec-%typedarray%.prototype.withSpliced">
                    <h1>%TypedArray%.prototype.withSpliced ( _start_, _deleteCount_, ..._items_ )</h1>

                    <p>When the *withSpliced* method is called, the following steps are taken:</p>

                    <emu-alg>
                        1. Let _O_ be the *this* value.
                        1. Perform ? ValidateTypedArray(_O_).
                        1. Let _len_ be _O_.[[ArrayLength]].
                        1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).
                        1. If _relativeStart_ is -&infin;, let _actualStart_ be 0.
                        1. Else if _relativeStart_ &lt; 0, let _actualStart_ be max(_len_ + _relativeStart_, 0).
                        1. Else, let _actualStart_ be min(_relativeStart_, _len_).
                        1. If _start_ is not present, then
                            1. Let _insertCount_ be 0.
                            1. Let _actualDeleteCount_ be 0.
                        1. Else if _deleteCount_ is not present, then
                            1. Let _insertCount_ be 0.
                            1. Let _actualDeleteCount_ be _len_ - _actualStart_.
                        1. Else,
                            1. Let _insertCount_ be the number of elements in _items_.
                            1. Let _dc_ be ? ToIntegerOrInfinity(_deleteCount_).
                            1. Let _actualDeleteCount_ be the result of clamping _dc_ between 0 and _len_ - _actualStart_.
                        1. Let _newLen_ be _len_ + _insert_Count_ - _actualDeleteCount_.
                        1. Let _A_ be ? TypedArraySpeciesCreate(_O_, &laquo; ùîΩ(_newLen_) &raquo;, *true*).
                        1. Perform ? TypedArrayCopyRange(_O_, _A_, *0*<sub>ùîΩ</sub>, ùîΩ(_actualStart_)).
                        1. Let _k_ be _actualStart_.
                        1. For each element _E_ of _items_, do
                            1. Let _Pk_ be ! ToString(ùîΩ(_k_)).
                            1. Perform ? Set(_A_, _Pk_, _E_, *true*).
                            1. Set _k_ to _k_ + 1.
                        1. Repeat, while _k_ &lt; _newLen_,
                            1. Let _Pk_ be ! ToString(ùîΩ(_k_)).
                            1. Let _from_ be ! ToString(ùîΩ(_k_ + _actualDeleteCount_ - _insertCount_)).
                            1. Let _fromValue_ be ! Get(_O_, _from_).
                            1. Perform ? Set(_A_, _Pk_, _fromValue_, *true*).
                            1. Set _k_ to _k_ + 1.
                        1. Return _A_.
                    </emu-alg>
                </emu-clause>

                <emu-clause id="sec-%typedarray%.prototype.withUnshifted">
                    <h1>%TypedArray%.prototype.withUnshifted ( ..._items_ )</h1>

                    <p>When the *withUnshifted* method is called, the following steps are taken:</p>

                    <emu-alg>
                        1. Let _itemCount_ be the number of elements in _items_.
                        1. Let _O_ be the *this* value.
                        1. Perform ? ValidateTypedArray(_O_).
                        1. Let _len_ be _O_.[[ArrayLength]].
                        1. Let _newLen_ be _len_ + _itemCount_.
                        1. Let _A_ be ? TypedArraySpeciesCreate(_O_, &laquo; ùîΩ(_newLen_) &raquo;, *true*).
                        1. Let _k_ be 0.
                        1. For each element _E_ of _items_, do
                            1. Let _Pk_ be ! ToString(ùîΩ(_k_)).
                            1. Perform ? Set(_A_, _Pk_, _E_, *true*).
                            1. Set _k_ to _k_ + 1.
                        1. Let _from_ be 0.
                        1. Repeat, while _k_ &lt; _newLen_,
                            1. Let _Pk_ be ! ToString(ùîΩ(_k_)).
                            1. Let _Pfrom_ be ! ToString(ùîΩ(_from_)).
                            1. Let _fromValue_ be ! Get(_O_, _Pfrom_).
                            1. Perform ? Set(_A_, _Pk_, _fromValue_, *true*).
                            1. Set _k_ to _k_ + 1.
                            1. Set _from_ to _from_ + 1.
                        1. Return _A_.
                    </emu-alg>
                </emu-clause>

                <emu-clause id="sec-%typedarray%.prototype.withAt">
                    <h1>%TypedArray%.prototype.withAt ( _index_, _value_ )</h1>

                    <p>When the *withAt* method is called, the following steps are taken:</p>

                    <emu-alg>
                        1. Let _O_ be the *this* value.
                        1. Perform ? ValidateTypedArray(_O_).
                        1. Let _len_ be _O_.[[ArrayLength]].
                        1. If IsIntegralNumber(_index_) is *false*, throw a *RangeError* exception.
                        1. If _index_ &lt; 0, let _actualIndex_ be _len_ + _index_.
                        1. Else, let _actualIndex_ be _index_.
                        1. If ! IsValidIntegerIndex(_O_, _actualIndex_) is *false*, throw a *RangeError* exception.
                        1. Let _A_ be ? TypedArraySpeciesCreate(_O_, &laquo; ùîΩ(_len_) &raquo;, *true*).
                        1. Let _k_ be 0.
                        1. Repeat, while _k_ &lt; _len_,
                            1. Let _Pk_ be ! ToString(ùîΩ(_k_)).
                            1. If _k_ is _actualIndex_, let _fromValue_ be _value_.
                            1. Else, let _fromValue_ be ! Get(_O_, _Pk_).
                            1. Perform ? Set(_A_, _Pk_, _fromValue_, *true*).
                            1. Set _k_ to _k_ + 1.
                        1. Return _A_.
                    </emu-alg>
                </emu-clause>
            </emu-clause>
        </emu-clause>
    </emu-clause>
</emu-clause>